<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ê∞∑„Éñ„É≠„ÉÉ„ÇØÂ¥©„Åó10„É©„Ç¶„É≥„Éâ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            background-image: radial-gradient(circle at 50% 120%, #102040 0%, #000010 80%);
            font-family: sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 15px;
            box-sizing: border-box;
        }
        .hud {
            color: #fff;
            text-shadow: 0 0 5px #00ffff;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }
        #lives-canvas { display: block; }
        #message-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            opacity: 1;
            transition: opacity 0.3s;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 20;
        }
        h1 {
            font-size: 40px;
            margin: 0 0 20px 0;
            background: linear-gradient(to right, #aaddff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0,150,255,0.6);
            text-align: center;
            letter-spacing: 2px;
        }
        p { font-size: 16px; color: #aaccff; margin: 5px 0; text-align: center; }
        .btn {
            margin-top: 25px;
            padding: 15px 50px;
            font-size: 22px;
            background: linear-gradient(135deg, #4488ff, #0044aa);
            border: 2px solid #88ccff;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
            transition: 0.1s;
            pointer-events: auto;
            font-weight: bold;
            text-transform: uppercase;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0, 150, 255, 0.8); background: linear-gradient(135deg, #66aaff, #0066cc); }
        .btn:active { transform: scale(0.95); }
        
        .legend {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(100,200,255,0.2);
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 14px; color: #ddeeff; }
        .hidden { display: none !important; pointer-events: none !important; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div class="hud">
        <div>
            <div id="score-display">SCORE: 0</div>
            <div id="level-display" style="font-size: 16px; color: #88aaff;">STAGE: 1</div>
        </div>
        <canvas id="lives-canvas" width="200" height="30"></canvas>
    </div>
</div>

<div id="message-overlay">
    <h1 id="title-text">PARIN CRASH</h1>
    <p id="sub-text">Tap Start to Play</p>
    
    <div class="legend">
        <div class="legend-item"><span style="color:#0ff">‚óè‚óè‚óè</span> Multi Ball (Max 6)</div>
        <div class="legend-item"><span style="color:#0f0">‚ÜîÔ∏è</span> Expand</div>
        <div class="legend-item"><span style="color:#fa0">‚ö°</span> Auto Laser (5s)</div>
        <div class="legend-item"><span style="color:#f44">üí£</span> TNT Penetrate</div>
    </div>

    <button id="start-btn" class="btn">GAME START</button>
</div>

<script>
/**
 * Audio System
 */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    playTone: function(freq, type, duration, vol=0.1, slide=0) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) {
            osc.frequency.exponentialRampToValueAtTime(Math.max(1, freq + slide), this.ctx.currentTime + duration);
        }
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol=0.2, hpFilterFreq = 0) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        noise.connect(gain);
        if (hpFilterFreq > 0) {
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = hpFilterFreq;
            gain.connect(filter); filter.connect(this.ctx.destination);
        } else {
            gain.connect(this.ctx.destination);
        }
        noise.start();
    },
    // „Äê„ÉÄ„É°„Éº„Ç∏Èü≥„Äë„Éë„É™„É≥ÔºàËªΩ„ÅÑ„Ç¨„É©„ÇπÈü≥Ôºâ
    playGlassDamage: function() { 
        if(!this.ctx) return;
        // È´òÈü≥„ÅÆÁü≠„ÅÑ„Éà„Éº„É≥„Åß„Äå„ÉÅ„É™„É≥„ÄçÊÑü„ÇíÂá∫„Åô
        this.playTone(2000, 'sine', 0.05, 0.1);
        this.playTone(3500, 'triangle', 0.05, 0.05);
        // Â∞ë„Åó„Å†„Åë„Éé„Ç§„Ç∫„ÇíÊ∑∑„Åú„Å¶„ÄåÂâ≤„Çå„Åã„Åë„ÄçÊÑü„ÇíÂá∫„Åô
        this.playNoise(0.05, 0.1, 3000);
    },
    // „ÄêÁ†¥Â£äÈü≥„Äë„Ç¨„Ç∑„É£„Éº„É≥ÔºàÈáç„ÅÑ„Ç¨„É©„ÇπÁ†¥Á†ïÈü≥Ôºâ
    playGlassBreak: function() { 
        if(!this.ctx) return;
        // ÊøÄ„Åó„ÅÑ„Éé„Ç§„Ç∫
        this.playNoise(0.3, 0.4, 500); 
        // Ë§áÊï∞„ÅÆ‰∏çÂçîÂíåÈü≥„ÇíÈáç„Å≠„Å¶Ë§áÈõë„Å™Èüø„Åç„Å´
        this.playTone(1500, 'sawtooth', 0.15, 0.15, -500); 
        this.playTone(2500, 'square', 0.1, 0.1);
        setTimeout(() => this.playTone(3500, 'sine', 0.2, 0.1), 20); // ÈÅÖ„Çå„Å¶Èüø„ÅèÈ´òÈü≥
        setTimeout(() => this.playTone(800, 'sawtooth', 0.2, 0.1, -200), 10); // ‰ΩéÈü≥„ÅÆË°ùÊíÉ
    },
    
    playHitSoft: function() { this.playTone(400, 'sine', 0.05, 0.1); },
    playLaser: function() { this.playTone(1000, 'sawtooth', 0.05, 0.02, -800); },
    playExplosion: function() { this.playNoise(0.4, 0.6); this.playTone(60, 'sawtooth', 0.3, 0.4, -60); },
    playPowerUp: function() { this.playTone(900, 'sine', 0.1, 0.1); setTimeout(() => this.playTone(1500, 'sine', 0.2, 0.1), 80); },
    playSplit: function() { this.playTone(500, 'sine', 0.1, 0.1, 300); },
    playDamage: function() { this.playTone(120, 'sawtooth', 0.3, 0.2, -40); },
    playDrill: function() {
        if(!this.ctx) return;
        this.playNoise(0.15, 0.5, 200);
        this.playTone(150, 'square', 0.1, 0.1, -100);
    }
};

/**
 * Game Constants & State
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const LIVES_CANVAS = document.getElementById('lives-canvas');
const LIVES_CTX = LIVES_CANVAS.getContext('2d');

const UI = {
    score: document.getElementById('score-display'),
    level: document.getElementById('level-display'),
    overlay: document.getElementById('message-overlay'),
    title: document.getElementById('title-text'),
    sub: document.getElementById('sub-text'),
    btn: document.getElementById('start-btn')
};

const STATE = { MENU: 0, PLAYING: 1, GAME_OVER: 2, LEVEL_CLEAR: 3, VICTORY: 4 };
let gameState = STATE.MENU;
let lastTime = 0;

const MAX_LEVELS = 10;
const INITIAL_LIVES = 6;
const MAX_BALLS = 6; 

let lives = INITIAL_LIVES;
let score = 0;
let currentLevel = 1;

let paddle;
let balls = [];
let bricks = [];
let powerUps = [];
let particles = [];
let shards = [];
let lasers = [];
let inputX = 0;

let tntActive = false;
let tntTimer = 0;

/**
 * Setup
 */
function resize() {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
    if(paddle) paddle.y = CANVAS.height - 70;
}
window.addEventListener('resize', resize);

function handleInput(x) { inputX = x; }
function handleAction() {
    AudioSys.init();
    if (gameState === STATE.PLAYING) {
        let launched = false;
        balls.forEach(b => {
            if (b.stuck) {
                b.launch();
                launched = true;
            }
        });
    }
}

window.addEventListener('mousemove', e => handleInput(e.clientX));
window.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, {passive:false});
window.addEventListener('mousedown', handleAction);
window.addEventListener('touchstart', handleAction);
window.addEventListener('keydown', e => { if(e.code === 'Space') handleAction(); });

UI.btn.addEventListener('click', () => {
    AudioSys.init();
    if (gameState === STATE.GAME_OVER || gameState === STATE.VICTORY) {
        lives = INITIAL_LIVES; score = 0; currentLevel = 1;
        startLevel(currentLevel);
    } else {
        lives = INITIAL_LIVES; score = 0; currentLevel = 1;
        startLevel(currentLevel);
    }
    AudioSys.playPowerUp();
});

/**
 * Classes
 */
class Paddle {
    constructor() {
        this.baseWidth = 110;
        this.width = this.baseWidth;
        this.height = 14;
        this.x = CANVAS.width/2 - this.width/2;
        this.y = CANVAS.height - 70;
        this.laserActive = false;
        this.laserTimer = 0;
        this.expandTimer = 0;
        this.lastShotTime = 0;
    }
    update(dt) {
        let targetX = inputX - this.width/2;
        targetX = Math.max(0, Math.min(CANVAS.width - this.width, targetX));
        this.x += (targetX - this.x) * 0.3;

        if (this.expandTimer > 0) {
            this.expandTimer -= dt;
            this.width = this.baseWidth * 1.5;
            if (this.expandTimer <= 0) this.width = this.baseWidth;
        }
        if (this.laserActive) {
            this.laserTimer -= dt;
            if (this.laserTimer <= 0) this.laserActive = false;
            this.shoot();
        }
    }
    draw() {
        CTX.save();
        CTX.shadowBlur = 15;
        CTX.shadowColor = this.laserActive ? '#ff4400' : '#00aaff';
        
        let grad = CTX.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
        grad.addColorStop(0, this.laserActive ? '#fff0f0' : '#e0f0ff');
        grad.addColorStop(0.5, this.laserActive ? '#ff2200' : '#0088ff');
        grad.addColorStop(1, '#002244');
        
        CTX.fillStyle = grad;
        CTX.beginPath();
        CTX.roundRect(this.x, this.y, this.width, this.height, 8);
        CTX.fill();
        
        CTX.fillStyle = 'rgba(255,255,255,0.4)';
        CTX.fillRect(this.x + 10, this.y + 3, this.width - 20, 2);

        if (this.laserActive) {
            CTX.fillStyle = '#ffaa00';
            const recoil = Math.sin(Date.now() / 50) * 2;
            CTX.fillRect(this.x + 8, this.y - 6 + (recoil>0?recoil:0), 4, 8);
            CTX.fillRect(this.x + this.width - 12, this.y - 6 + (recoil>0?recoil:0), 4, 8);
        }
        CTX.restore();
    }
    shoot() {
        if (!this.laserActive) return;
        const now = Date.now();
        if (now - this.lastShotTime > 300) {
            lasers.push(new Laser(this.x + 10, this.y));
            lasers.push(new Laser(this.x + this.width - 10, this.y));
            this.lastShotTime = now;
            AudioSys.playLaser();
        }
    }
}

class Ball {
    constructor(x, y, dx, dy, isStuck = false) {
        this.radius = 6;
        this.x = x || CANVAS.width/2;
        this.y = y || CANVAS.height - 100;
        this.dx = dx || 0;
        this.dy = dy || 0;
        this.stuck = isStuck;
        this.speed = 3.5; 
        this.maxSpeed = 6.5; 
    }

    launch() {
        if (this.stuck) {
            this.stuck = false;
            this.dy = -this.speed;
            this.dx = (Math.random() * 2 - 1) * (this.speed * 0.8);
            AudioSys.playHitSoft();
        }
    }

    update() {
        if (this.stuck) {
            this.x = paddle.x + paddle.width/2;
            this.y = paddle.y - this.radius - 2;
            return;
        }

        const steps = 4;
        const stepDx = this.dx / steps;
        const stepDy = this.dy / steps;

        for (let i = 0; i < steps; i++) {
            this.x += stepDx;
            this.y += stepDy;

            let collided = false;
            if (this.x < this.radius) { this.x = this.radius; this.dx = Math.abs(this.dx); collided = true; }
            if (this.x > CANVAS.width - this.radius) { this.x = CANVAS.width - this.radius; this.dx = -Math.abs(this.dx); collided = true; }
            if (this.y < this.radius) { this.y = this.radius; this.dy = Math.abs(this.dy); collided = true; }
            if (collided) AudioSys.playHitSoft();

            if (this.dy > 0 && 
                this.y + this.radius >= paddle.y && 
                this.y - this.radius <= paddle.y + paddle.height &&
                this.x >= paddle.x && this.x <= paddle.x + paddle.width) {
                
                this.dy = -Math.abs(this.dy);
                this.y = paddle.y - this.radius - 1;
                let hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
                this.dx = hitPos * (this.speed * 1.5); 
                
                let currentSpeed = Math.hypot(this.dx, this.dy);
                if (currentSpeed > this.maxSpeed) {
                    let scale = this.maxSpeed / currentSpeed;
                    this.dx *= scale;
                    this.dy *= scale;
                }
                AudioSys.playHitSoft();
                createParticles(this.x, this.y, '#ffffff', 5);
                break;
            }

            let hitBlock = false;
            for (let b of bricks) {
                if (!b.active) continue;
                if (this.x + this.radius > b.x && this.x - this.radius < b.x + b.w &&
                    this.y + this.radius > b.y && this.y - this.radius < b.y + b.h) {
                    
                    if (!tntActive) {
                        const overlapLeft = (this.x + this.radius) - b.x;
                        const overlapRight = (b.x + b.w) - (this.x - this.radius);
                        const overlapTop = (this.y + this.radius) - b.y;
                        const overlapBottom = (b.y + b.h) - (this.y - this.radius);
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft || minOverlap === overlapRight) this.dx *= -1;
                        else this.dy *= -1;
                    } else {
                        AudioSys.playDrill(); // Ë≤´ÈÄöÈü≥
                        createParticles(this.x, this.y, '#ff4400', 10);
                    }
                    
                    b.hit(tntActive ? 10 : 1);
                    hitBlock = true;
                    break;
                }
            }
            if (hitBlock) break;
        }
    }

    draw() {
        CTX.save();
        CTX.translate(this.x, this.y);
        
        if (tntActive) {
            // TNT„Éú„Éº„É´
            CTX.shadowBlur = 15;
            CTX.shadowColor = '#ff2200';
            const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
            CTX.scale(pulse, pulse);
            let grad = CTX.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            grad.addColorStop(0, '#ffff00');
            grad.addColorStop(1, '#ff0000');
            CTX.fillStyle = grad;
            CTX.beginPath();
            CTX.arc(0, 0, this.radius, 0, Math.PI * 2);
            CTX.fill();
        } else {
            // ÈÄöÂ∏∏„Éú„Éº„É´
            CTX.shadowBlur = 8;
            CTX.shadowColor = '#88ffff';
            let grad = CTX.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            grad.addColorStop(0, '#ffffff');
            grad.addColorStop(0.5, '#d0eeff');
            grad.addColorStop(1, '#0088ff');
            CTX.fillStyle = grad;
            CTX.beginPath();
            CTX.arc(0, 0, this.radius, 0, Math.PI * 2);
            CTX.fill();
        }
        CTX.restore();
    }
}

class Brick {
    constructor(x, y, w, h, type, level) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.type = type; // 0:Crystal, 1:Hard, 2:TNT
        this.active = true;
        
        if (type === 1) {
            this.maxHp = 2 + Math.floor(level / 2.5);
            this.hp = this.maxHp;
        } else {
            this.maxHp = 1; this.hp = 1;
        }

        this.cracks = [];
        const numCracks = 3; 
        for(let i=0; i<numCracks; i++) {
            const cx = 0.3 + Math.random() * 0.4;
            const cy = 0.3 + Math.random() * 0.4;
            const points = [];
            const branches = 3 + Math.floor(Math.random() * 3);
            for(let j=0; j<branches; j++) {
                const angle = (Math.PI * 2 * j / branches) + (Math.random() * 0.5);
                const len = 0.3 + Math.random() * 0.5;
                points.push({
                    x1: cx, y1: cy,
                    x2: cx + Math.cos(angle) * len, y2: cy + Math.sin(angle) * len
                });
                if (Math.random() > 0.5) {
                    points.push({
                        x1: cx + Math.cos(angle) * (len*0.5), y1: cy + Math.sin(angle) * (len*0.5),
                        x2: cx + Math.cos(angle + 0.5) * (len*0.5), y2: cy + Math.sin(angle + 0.5) * (len*0.5)
                    });
                }
            }
            this.cracks.push(points);
        }
        
        this.hue = 190 + Math.random() * 30;
    }

    draw() {
        if (!this.active) return;
        CTX.save();
        const isHard = (this.type === 1);
        
        if (this.type === 2) { 
            CTX.fillStyle = 'rgba(255, 50, 0, 0.7)';
            CTX.fillRect(this.x, this.y, this.w, this.h);
            CTX.strokeStyle = '#ffaa00';
            CTX.lineWidth = 2;
            CTX.strokeRect(this.x, this.y, this.w, this.h);
            CTX.fillStyle = '#ffff00';
            CTX.font = 'bold 11px sans-serif';
            CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
            CTX.fillText("TNT", this.x + this.w/2, this.y + this.h/2); 
        } else {
            let baseColor;
            if (isHard) {
                baseColor = `hsla(220, 80%, 30%, 0.85)`;
            } else {
                baseColor = `hsla(${this.hue}, 90%, 60%, 0.7)`;
            }

            let grad = CTX.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
            grad.addColorStop(0, 'rgba(255,255,255,0.4)');
            grad.addColorStop(0.5, baseColor);
            grad.addColorStop(1, isHard ? 'rgba(0,10,50,0.8)' : `hsla(${this.hue}, 90%, 40%, 0.8)`);
            
            CTX.fillStyle = grad;
            CTX.fillRect(this.x, this.y, this.w, this.h);
            
            CTX.strokeStyle = isHard ? 'rgba(200,220,255,0.8)' : 'rgba(255,255,255,0.6)';
            CTX.lineWidth = isHard ? 2 : 1;
            CTX.strokeRect(this.x, this.y, this.w, this.h);

            CTX.fillStyle = 'rgba(255,255,255,0.25)';
            CTX.beginPath();
            CTX.moveTo(this.x, this.y);
            CTX.lineTo(this.x + this.w * 0.7, this.y);
            CTX.lineTo(this.x, this.y + this.h * 0.7);
            CTX.fill();

            if (isHard && this.hp < this.maxHp) {
                CTX.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                CTX.lineWidth = 1.2;
                CTX.beginPath();
                const damagePercent = (this.maxHp - this.hp) / this.maxHp; 
                const visibleCracks = Math.ceil(damagePercent * this.cracks.length);
                for(let i=0; i < visibleCracks; i++) {
                    const crackGroup = this.cracks[i];
                    for (let p of crackGroup) {
                        CTX.moveTo(this.x + this.w * p.x1, this.y + this.h * p.y1);
                        CTX.lineTo(this.x + this.w * p.x2, this.y + this.h * p.y2);
                    }
                }
                CTX.stroke();
            }
        }
        CTX.restore();
    }
    
    hit(damage) {
        this.hp -= damage;
        createParticles(this.x+this.w/2, this.y+this.h/2, '#ccffff', 4);
        
        if (this.hp > 0) {
            // „ÉÄ„É°„Éº„Ç∏Èü≥Ôºö„Éë„É™„É≥ÔºàËªΩ„ÅÑ„Ç¨„É©„ÇπÈü≥Ôºâ
            AudioSys.playGlassDamage();
        } else {
            this.active = false;
            score += (this.type + 1) * 100;
            
            // Á†¥Â£äÈü≥„ÅÆÂàÜÂ≤ê
            if (this.type === 2) AudioSys.playExplosion(); // TNT: ÁàÜÁô∫
            else AudioSys.playGlassBreak(); // ÈÄöÂ∏∏ & Hard: „Ç¨„Ç∑„É£„Éº„É≥ÔºàÊ¥æÊâã„Å™„Ç¨„É©„ÇπÁ†¥Â£äÈü≥Ôºâ
            
            let shardColor;
            if (this.type === 2) shardColor = '#ff5500';
            else if (this.type === 1) shardColor = '#88aaff';
            else shardColor = `hsl(${this.hue}, 80%, 80%)`;
            
            createShards(this.x, this.y, this.w, this.h, shardColor);
            
            const dropRate = 0.15 + (Math.random() * 0.1); 
            if (Math.random() < dropRate) powerUps.push(new PowerUp(this.x + this.w/2, this.y + this.h/2));

            // TNT„Éñ„É≠„ÉÉ„ÇØÁ†¥Â£äÊôÇ -> Âë®Âõ≤Á†¥Â£äÁàÜÁô∫
            if (this.type === 2) {
                 triggerExplosion(this.x + this.w/2, this.y + this.h/2, true);
            }
            checkClear();
        }
    }
}

class PowerUp {
    constructor(x, y) {
        this.x = x; this.y = y; this.dy = 2; this.active = true;
        const r = Math.random();
        if (r < 0.25) this.type = 'SPLIT';
        else if (r < 0.50) this.type = 'EXPAND';
        else if (r < 0.75) this.type = 'LASER';
        else this.type = 'TNT'; // Penetrate
    }
    update() {
        this.y += this.dy;
        if (this.y > CANVAS.height) this.active = false;
        if (this.active && 
            this.x > paddle.x && this.x < paddle.x + paddle.width &&
            this.y + 15 > paddle.y && this.y - 15 < paddle.y + paddle.height) {
            this.activate();
            this.active = false;
        }
    }
    activate() {
        score += 300;
        AudioSys.playPowerUp();
        createParticles(paddle.x + paddle.width/2, paddle.y, '#fff', 10);
        if (this.type === 'SPLIT') {
            AudioSys.playSplit();
            const currentCount = balls.length;
            const maxAdd = 2;
            let slots = MAX_BALLS - currentCount;
            let addCount = Math.min(slots, maxAdd);

            if (addCount > 0) {
                let newBalls = [];
                for (let i = 0; i < addCount; i++) {
                    const sourceBall = balls[i % balls.length];
                    const speed = Math.hypot(sourceBall.dx, sourceBall.dy);
                    const currentAngle = Math.atan2(sourceBall.dy, sourceBall.dx);
                    
                    const angleOffset = (i % 2 === 0 ? -1 : 1) * 0.35; 
                    const newAngle = currentAngle + angleOffset;
                    
                    const newDx = Math.cos(newAngle) * speed;
                    const newDy = Math.sin(newAngle) * speed;

                    newBalls.push(new Ball(sourceBall.x, sourceBall.y, newDx, newDy, false));
                }
                balls = balls.concat(newBalls);
            }
        } else if (this.type === 'EXPAND') {
            paddle.expandTimer = 10000;
        } else if (this.type === 'LASER') {
            paddle.laserActive = true; 
            paddle.laserTimer = 5000;
        } else if (this.type === 'TNT') {
            tntActive = true; 
            tntTimer = 10000;
        }
    }
    draw() {
        if (!this.active) return;
        CTX.save();
        CTX.translate(this.x, this.y);
        CTX.beginPath(); CTX.arc(0, 0, 15, 0, Math.PI*2);
        CTX.fillStyle = 'rgba(0, 20, 60, 0.6)'; CTX.fill();
        CTX.strokeStyle = '#88ccff'; CTX.lineWidth = 2; CTX.stroke();
        if (this.type === 'SPLIT') {
            CTX.fillStyle = '#00ffff';
            CTX.beginPath(); CTX.arc(-6, 4, 4, 0, Math.PI*2); CTX.fill();
            CTX.beginPath(); CTX.arc(6, 4, 4, 0, Math.PI*2); CTX.fill();
            CTX.beginPath(); CTX.arc(0, -5, 4, 0, Math.PI*2); CTX.fill();
        } else if (this.type === 'EXPAND') {
            CTX.fillStyle = '#00ff88';
            CTX.fillRect(-8, -2, 16, 4);
            CTX.beginPath(); CTX.moveTo(-10,0); CTX.lineTo(-4,-4); CTX.lineTo(-4,4); CTX.fill();
            CTX.beginPath(); CTX.moveTo(10,0); CTX.lineTo(4,-4); CTX.lineTo(4,4); CTX.fill();
        } else if (this.type === 'LASER') {
            CTX.fillStyle = '#ffaa00';
            CTX.beginPath(); CTX.moveTo(0,-8); CTX.lineTo(-5,0); CTX.lineTo(5,0); CTX.fill(); CTX.fillRect(-2,0,4,8);
        } else if (this.type === 'TNT') {
            CTX.fillStyle = '#ff4444';
            CTX.beginPath(); CTX.arc(0, 2, 6, 0, Math.PI*2); CTX.fill();
            CTX.fillStyle = '#ffff00'; 
            CTX.fillRect(0, -8, 2, 4);
        }
        CTX.restore();
    }
}

class Laser {
    constructor(x, y) { this.x = x; this.y = y; this.dy = -15; this.active = true; }
    update() {
        if (!this.active) return;
        this.y += this.dy;
        if(this.y < 0) this.active = false;
        for(let b of bricks) {
            if(b.active && this.x > b.x && this.x < b.x + b.w && this.y < b.y + b.h && this.y + 20 > b.y) {
                b.hit(1); 
                this.active = false; 
                createParticles(this.x, this.y, '#fa0', 5); 
                break;
            }
        }
    }
    draw() {
        if(!this.active) return;
        CTX.fillStyle = '#ffaa00'; CTX.fillRect(this.x - 2, this.y, 4, 20);
        CTX.fillStyle = '#ffffff'; CTX.fillRect(this.x - 1, this.y, 2, 20);
    }
}

class Shard {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed - 2;
        this.gravity = 0.3; this.life = 1.0; this.size = Math.random() * 5 + 3;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.02; }
    draw() {
        CTX.save(); CTX.globalAlpha = this.life; CTX.fillStyle = this.color;
        CTX.translate(this.x, this.y); CTX.rotate(this.life * 5);
        CTX.beginPath(); CTX.moveTo(0, -this.size); CTX.lineTo(this.size, this.size); CTX.lineTo(-this.size, this.size); CTX.fill();
        CTX.restore();
    }
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) particles.push({ x: x, y: y, color: color, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 1.0 });
}
function createShards(x, y, w, h, color) {
    for(let i=0; i<6; i++) shards.push(new Shard(x + Math.random()*w, y + Math.random()*h, color));
}
function triggerExplosion(x, y, withDamage = false) {
    AudioSys.playExplosion();
    createParticles(x, y, '#ff5500', 30);
    if (withDamage) {
        bricks.forEach(b => {
            if (b.active) {
                const dist = Math.hypot((b.x+b.w/2)-x, (b.y+b.h/2)-y);
                if (dist < 70) b.hit(10);
            }
        });
    }
}

/**
 * Game Logic
 */
function startLevel(lvl) {
    currentLevel = lvl;
    gameState = STATE.PLAYING;
    UI.overlay.classList.add('hidden');
    paddle = new Paddle();
    balls = [new Ball(0, 0, 0, 0, true)];
    tntActive = false;
    powerUps = []; lasers = []; particles = []; shards = [];
    generateLevel(lvl);
    drawLives();
}

function generateLevel(lvl) {
    bricks = [];
    const cw = CANVAS.width;
    const pattern = (lvl - 1) % 4;
    const startY = 100;

    if (pattern === 0) { // Grid
        const cols = Math.min(16, 8 + lvl);
        const rows = Math.min(10, 5 + Math.floor(lvl/2));
        const padding = 2;
        const w = (cw - 20) / cols;
        const h = 20;
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                addBrick(10 + c*w + padding, startY + r*(h+padding), w - padding*2, h, lvl);
            }
        }
    } else if (pattern === 1) { // Pyramid
        const rows = 10 + lvl;
        const w = 35;
        const h = 20;
        for(let r=0; r<rows; r++) {
            const cols = r + 2;
            const startX = (cw - cols*w)/2;
            for(let c=0; c<cols; c++) addBrick(startX + c*w, startY + r*(h+2), w-2, h, lvl);
        }
    } else if (pattern === 2) { // Circle
        const cx = cw/2, cy = startY + 150;
        for(let ring=1; ring<=4+Math.floor(lvl/3); ring++) {
            const r = ring * 40;
            const count = Math.floor(2*Math.PI*r/35);
            for(let i=0; i<count; i++) {
                const angle = i/count * Math.PI*2;
                addBrick(cx + Math.cos(angle)*r - 15, cy + Math.sin(angle)*r*0.6 - 10, 30, 18, lvl);
            }
        }
    } else { // Random
        for(let i=0; i<50 + lvl*8; i++) {
            addBrick(Math.random()*(cw-40)+20, Math.random()*(CANVAS.height/3)+startY, 40, 18, lvl);
        }
    }
}

function addBrick(x, y, w, h, lvl) {
    let type = 0;
    const hardRate = 0.1 + lvl * 0.05;
    const tntRate = 0.03 + lvl * 0.01;
    if(Math.random() < tntRate) type = 2;
    else if(Math.random() < hardRate) type = 1;
    bricks.push(new Brick(x, y, w, h, type, lvl));
}

function checkClear() {
    if(bricks.filter(b => b.active).length === 0) {
        if(currentLevel >= MAX_LEVELS) {
            gameState = STATE.VICTORY;
            UI.title.innerText = "CONGRATULATIONS!";
            UI.sub.innerText = "All Stages Cleared!";
            UI.btn.innerText = "RESTART GAME";
        } else {
            gameState = STATE.LEVEL_CLEAR;
            UI.title.innerText = "STAGE CLEAR!";
            UI.sub.innerText = "Next Stage...";
            UI.btn.classList.add('hidden');
            setTimeout(() => startLevel(currentLevel + 1), 2000);
        }
        UI.overlay.classList.remove('hidden');
        if(gameState === STATE.VICTORY) UI.btn.classList.remove('hidden');
    }
}

function loseLife() {
    lives--;
    drawLives();
    AudioSys.playDamage();
    if (lives < 0) {
        gameState = STATE.GAME_OVER;
        UI.title.innerText = "GAME OVER";
        UI.sub.innerText = `Score: ${score} - Stage ${currentLevel}`;
        UI.btn.innerText = "CONTINUE";
        UI.btn.classList.remove('hidden');
        UI.overlay.classList.remove('hidden');
    } else {
        balls = [new Ball(0, 0, 0, 0, true)];
        paddle.laserActive = false;
        tntActive = false;
    }
}

function drawLives() {
    LIVES_CTX.clearRect(0, 0, LIVES_CANVAS.width, LIVES_CANVAS.height);
    for(let i=0; i<lives; i++) {
        if (i > 10) break;
        const x = 15 + i * 25;
        const y = 15;
        LIVES_CTX.beginPath(); LIVES_CTX.arc(x, y, 7, 0, Math.PI*2);
        LIVES_CTX.fillStyle = '#00aaff'; LIVES_CTX.fill();
        LIVES_CTX.fillStyle = 'rgba(255,255,255,0.7)'; LIVES_CTX.beginPath(); LIVES_CTX.arc(x-2, y-2, 2.5, 0, Math.PI*2); LIVES_CTX.fill();
    }
}

function loop() {
    const now = Date.now();
    const dt = now - lastTime;
    lastTime = now;

    if (tntActive) {
        tntTimer -= dt;
        if (tntTimer <= 0) tntActive = false;
    }

    CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);

    if (gameState === STATE.PLAYING || gameState === STATE.LEVEL_CLEAR) {
        if (gameState === STATE.PLAYING) {
            paddle.update(dt);
            for (let i = balls.length - 1; i >= 0; i--) {
                const b = balls[i];
                b.update();
                if (b.y > CANVAS.height + 20) balls.splice(i, 1);
            }
            if (balls.length === 0) loseLife();
            powerUps.forEach(p => p.update());
            lasers.forEach(l => l.update());
        }

        paddle.draw();
        bricks.forEach(b => b.draw());
        balls.forEach(b => b.draw());
        powerUps.forEach(p => p.draw());
        lasers.forEach(l => l.draw());
        
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            CTX.globalAlpha = Math.max(0, p.life); CTX.fillStyle = p.color; CTX.fillRect(p.x, p.y, 3, 3);
            if(p.life <= 0) particles.splice(i, 1);
        });
        shards.forEach((s, i) => {
            s.update(); s.draw();
            if(s.life <= 0 || s.y > CANVAS.height) shards.splice(i, 1);
        });
        
        CTX.globalAlpha = 1.0;
        UI.score.innerText = `SCORE: ${score}`;
        UI.level.innerText = `STAGE: ${currentLevel}`;
    }
    requestAnimationFrame(loop);
}

window.onload = () => { resize(); drawLives(); loop(); };
</script>
</body>
</html>
